# 성능 개선

컴포넌트가 리렌더링 되는 조건은 세 가지이다.

- 부모에서 전달받은 props가 변경될때
- 부모 컴포넌트가 리렌더링 될 때
- 자신의 state가 변경 될 때

위 조건에 따라 리렌더링이 되는데 불필요한 리렌더링은 성능을 저하시킨다. 따라서 이런 불필효한 동작을 최소화 하기 위해선 어떻게 해야할까?

## 1. useMemo 사용

useMemo는 React에서 CPU 소모가 심한 함수들을 캐싱하기 위해 사용된다. 종속 변수들이 변하지 않으면 함수를 굳이 다시 호출하지 않고 이전에 반환한 참조값을 재사용 해 함수 호출 시간도 세이브할 수 있고 같은 값을 props로 받는 하위 컴포넌트의 리렌더링도 방지할 수 있다.

## 2. useCallback 사용

useCallback은 함수 선언을 memoize 하는데 사용된다.
useCallback으로 함수를 선언해주면, 종속 변수들이 변하지 않는 이상 굳이 함수를 재생성하지 않고 이전에 있던 참조 변수를 그대로 하위 컴포넌트에 props로 전달하여, 하위 컴포넌트도 props가 변경되지 않았다고 인지하게 되어 하위 컴포넌트의 리렌더링을 방지할 수 있다.

### 3. 자식 컴포넌트의 props로 객체를 넘겨줄 경우 변형하지말고 넘겨주기

```js
// 생성자 함수
<Component prop={new Obj("x")} />
// 객체 리터럴
<Component prop={{property: "x"}} />
```

위와 같이 새로 생성된 객체를 props로 전달하는 경우 컴포넌트가 리렌더링 될 때마다 새로운 객체가 생성되어 자식 컴포넌트로 전달되기 때문에 메모이제이션 되지 않는다.

### 4. 컴포넌트를 매핑할 때에는 key값으로 index를 사용하지 않는다.

사람들이 많이 하는 실수 중에 하나가 바로 컴포넌트를 매핑할 때 key값에 index 값을 넣어준다.
리액트에서 매핍을 할떄 반드시 고유 key를 부여하도록 강제하고 있는데, 이렇게 index값으로 key값을 부여하면 좋지 않다.

어떤 배열에 중간에 어떤 요소가 삽입될때 그 중간 이후에 위치한 요소들은 전부 index가 변경된다.
이로 인해 key값이 변경되어 React는 key가 동일 할 경우, 동일한 DOM Element를 보여주기 때문에 예상치 못한 문제가 발생한다. 또한, 데이터가 key와 매치가 안되어 서로 꼬이는 부작용도 발생한다.

> **그러면 index 요소는 반드시 사용하면 안되는 걸까?**<br>
> 배열의 요소가 필터링, 정렬 삭제, 추가 등의 기능이 들어간다면 문제가 발생할수 있으나 다음과 같은 경우에서는 index로 사용해도 무방다.
> 다만, 가급적이면 코드의 일관성을 위해 최대한 index 를 사용 안하는 것을 권장한다.
>
> - 배열과 각 요소가 수정, 삭제, 추가 등의 기능이 없는 단순 렌더링만 담당하는 경우
> - id로 쓸만한 unique 값이 없을 경우
> - 정렬 혹은 필터 요소가 없어야 함
