# virtual DOM

실제 DOM과 같은 내용을 담고 있는 복사본으로 실제 DOM이 아닌 JS 객체 형태로 메모리 안에 저장되어 있음

실제 DOM의 복사본이기 때문에, 실제 DOM의 모든 element와 속성을 공유하지만 브라우저에 있는 문서에 직접적으로 접근할 수 없다. -> 화면에 보여지는 내용을 직접 수정할 수 없다.

### 직접 수정이 불가능한데 왜 virtual DOM을 사용할까?

만약 우리가 폰트의 컬러를 바꾸고 싶어 다음과 같은 DOM 조작을 했다고 하자

```
document.querySelector(‘#title”).style.color = “red”;
```

브라우저는 HTML을 탐색해 해당 Element를 찾고, 해당 Element와 자식 Element들을 DOM에서 제거한다. 이후 새롭게 수정된 Element로 이를 교체하는데, CSS는 이 과정 이후 다시 계산하여 결과적으로는 레이아웃 정보를 알맞게 수정하게 된다. 새롭게 계산된 내용이 브라우저에 그려지는 방식으로 플로우가 진행된다.

사실 DOM조작은 트리에 있는 정보를 업데이트시켜준다는 점, 그리고 빠른 알고리즘을 사용한다는 조건 하에선 그렇게 퍼포먼스적으로 무리가 있는 작업은 아니다.
하지만 이를 반복적으로 수행한다면? 충분히 무거워질 수 있는 작업이 될 것이다.

가상돔은 메모리에 저장되어 있는 자바스크립트 객체에 불과하기 때문에 가상돔에 접근하고 수정하는 것은 매우 가볍고 빠른 작업이 된다.

### 리액트는 어떤 방식으로 가상돔을 활용해 실제 DOM을 조작할까?

리액트는 두개의 가상돔 객체를 가진다.

1. 렌더링 이전 화면 구조를 나타내는 가상돔
2. 렌더링 이후에 보이게 될 화면 구조를 나타내는 가상돔

리액트는 STATE가 변경될 때마다 Re-Rendering이 발생하는데 실제 브라우저가 그려지기 이전에 새로운 내용이 담긴 가상돔을 생성하게 된다.
<img src="
https://miro.medium.com/v2/resize:fit:720/format:webp/1*JCrDk-N-wpPnE9j0GObItg.png"
/>
